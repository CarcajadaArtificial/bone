//   __  __        _ _         ___               _
//  |  \/  |___ __| (_)__ _   / _ \ _  _ ___ _ _(_)___ ___
//  | |\/| / -_) _` | / _` | | (_) | || / -_) '_| / -_|_-<
//  |_|  |_\___\__,_|_\__,_|  \__\_\\_,_\___|_| |_\___/__/
//
// =====================================================================================================
@use 'sass:map';
@use 'sass:list';
@use '../lib/sass-door' as *;
@use 'internal' as *;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// The `only-on` function is a Sass utility that allows you to create media queries for specific breakpoints defined in the `$breakpoint-map` map. The function uses the @media rule to create a media query that applies the enclosed styles only when the specified breakpoint is active
///
/// @param {string} $breakpoint-map
///   The map containing all the breakpoints.
///
/// @param {string} $breakpoint
///   One of the keys in the `$breakpoint-map` map.
///
/// @group media-queries
///
@function only-on($breakpoint-map, $breakpoint) {
  @if map.has-key($breakpoint-map, $breakpoint) {
    $start: map.get($breakpoint-map, $breakpoint);
    $end: map.get(
      $breakpoint-map,
      next-key-in-map($breakpoint-map, $breakpoint)
    );
    @if $end == null {
      @return 'screen and (min-width: #{$start})';
    } @else if $start == 0em {
      @return 'screen and (max-width: #{$end - 0.0625em})';
    } @else {
      @return 'screen and (min-width: #{$start}) and (max-width: #{$end - 0.0625em})';
    }
  } @else {
    @return throw(index-msg($breakpoint, '$breakpoints'));
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// This function generates a media query with a `min-width` based on the value associated with the provided `$breakpoint` key in the `$breakpoints` map. It can be used to apply styles for screens larger than a specific breakpoint.
///
/// @param {string} $breakpoint-map
///   The map containing all the breakpoints.
///
/// @param {string} $breakpoint
///   One of the keys in the `$breakpoints` map.
///
/// @group media-queries
///
@function larger-than($breakpoint-map, $breakpoint) {
  @if map.has-key($breakpoint-map, $breakpoint) {
    @return 'screen and (min-width: #{map.get($breakpoints, $breakpoint)})';
  } @else {
    @return throw(index-msg($breakpoint, '$breakpoints'));
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// This function generates a media query with a `max-width` based on the value associated with the provided `$breakpoint` key in the `$breakpoints` map. It can be used to apply styles for screens smaller than a specific breakpoint.
///
/// @param {string} $breakpoint-map
///   The map containing all the breakpoints.
///
/// @param {string} $breakpoint
///   One of the keys in the `$breakpoints` map.
///
/// @group media-queries
///
@function smaller-than($breakpoint-map, $breakpoint) {
  @if map.has-key($breakpoint-map, $breakpoint) {
    @return 'screen and (max-width: #{map.get($breakpoint-map, $breakpoint) - 0.0625em})';
  } @else {
    @return throw(index-msg($breakpoint, '$breakpoint-map'));
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// This function generates media queries with the specified min-width and max-width values based on a `$breakpoints` map. It is designed to simplify the process of creating responsive styles by allowing developers to easily define media queries using named breakpoints instead of specific pixel values.
///
/// @param {string} $breakpoint-map
///   The map containing all the breakpoints.
///
/// @param {string} $breakpoint-start
///   One of the keys in the `$breakpoints` map.
///
/// @param {string} $breakpoint-end
///   One of the keys in the `$breakpoints` map.
///
/// @group media-queries
///
@function between($breakpoint-map, $breakpoint-start, $breakpoint-end) {
  @if not map.has-key($breakpoints, $breakpoint-start) {
    @return throw(index-msg($breakpoint-start, '$breakpoints'));
  } @else if not map.has-key($breakpoints, $breakpoint-end) {
    @return throw(index-msg($breakpoint-end, '$breakpoints'));
  } @else if $breakpoint-start == $breakpoint-end {
    @return throw(value-msg($breakpoint-end, 'different breakpoints'));
  } @else {
    $start-width: map.get($breakpoints, $breakpoint-start);
    $end-width: map.get($breakpoints, $breakpoint-end) - 0.0625em;
    @return 'screen and (min-width: #{$start-width}) and (max-width: #{$end-width})';
  }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
/// This mixin generates CSS media queries based on a map of query names and corresponding query strings.
///
/// @param {map} $query-map A map containing the media queries to turn into classes.
///
/// @group media-queries
///
@mixin build-queries($query-map) {
  @each $name, $query in $query-map {
    .mq-#{$name} {
      display: none;

      @media #{$query} {
        display: block;
      }
    }
  }
}
